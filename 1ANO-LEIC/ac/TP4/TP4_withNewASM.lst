P16 assembler v1.5 (Feb  9 2024)	c:\uni\LEIC 2 ANO\2semestre\AC\projects_AC\ComputerArchProj\TP4\TP4_withNewASM.lst	Tue Jun 04 12:34:53 2024

Sections
Index   Name            Address   Size
0       startup         0000      0014 20
1       .text           0014      0274 628
2       .data           0288      0017 23
3       .stack          02A0      0040 64

Symbols
Name                    Type      Value       Section
_start                  LABEL     0004 4      startup
ARRAY_MASK              ABSOLUTE  0007 7      startup
ARRAY_POS               ABSOLUTE  0003 3      startup
BLINK_TIME              ABSOLUTE  0005 5      startup
button_state            LABEL     0288 648    .data
button_state_addr       LABEL     0130 304    .text
case_config             LABEL     00A8 168    .text
case_config_begin       LABEL     00AA 170    .text
case_config_l0          LABEL     00CE 206    .text
case_crossing_cars      LABEL     0044 68     .text
case_crossing_cars_begin LABEL     0046 70     .text
case_crossing_cars_l0   LABEL     006E 110    .text
case_crossing_cars_l1   LABEL     0072 114    .text
case_crossing_pedestrians LABEL     0076 118    .text
case_crossing_pedestrians_begin LABEL     0078 120    .text
case_crossing_pedestrians_l0 LABEL     00A0 160    .text
case_crossing_pedestrians_l1 LABEL     00A4 164    .text
CONFIG_MASK             ABSOLUTE  0010 16     startup
CONFIG_POS              ABSOLUTE  0004 4      startup
CONFIG_ST               ABSOLUTE  0004 4      startup
CROSSING_CARS_ST        ABSOLUTE  0000 0      startup
CROSSING_PEDESTRIAN_ST  ABSOLUTE  0002 2      startup
crossing_times          LABEL     028E 654    .data
crossing_times_addr     LABEL     00DE 222    .text
detect_rising_edge      LABEL     011A 282    .text
detect_rising_edge_l0   LABEL     012C 300    .text
ENABLE_EXTINT           ABSOLUTE  0010 16     startup
evaluate_state_cars     LABEL     00E0 224    .text
evaluate_state_cars_l0  LABEL     00F8 248    .text
evaluate_state_cars_l1  LABEL     00F0 240    .text
evaluate_state_cars_l2  LABEL     00F4 244    .text
evaluate_state_config   LABEL     00FA 250    .text
evaluate_state_config_l0 LABEL     0116 278    .text
evaluate_state_config_l1 LABEL     010C 268    .text
evaluate_state_config_l2 LABEL     0112 274    .text
get_config              LABEL     0172 370    .text
get_pedestrian_button   LABEL     0166 358    .text
get_time                LABEL     017E 382    .text
inport_addr             LABEL     0254 596    .text
INPORT_ADDRESS          ABSOLUTE  FF80 65408  startup
inport_read             LABEL     024E 590    .text
isr                     LABEL     01FC 508    .text
isr_addr                LABEL     0012 18     startup
led_state               LABEL     0289 649    .data
line#79                 LABEL     000C 12     startup
main                    LABEL     0014 20     .text
main_addr               LABEL     0010 16     startup
main_branch_table       LABEL     0038 56     .text
main_end                LABEL     00D2 210    .text
main_loop               LABEL     002C 44     .text
MODE_G_MASK             ABSOLUTE  0020 32     startup
MODE_R_MASK             ABSOLUTE  0010 16     startup
ONE                     ABSOLUTE  0001 1      startup
outport_addr            LABEL     0286 646    .text
OUTPORT_ADDRESS         ABSOLUTE  FFC0 65472  startup
outport_clear_bits      LABEL     0264 612    .text
outport_img             LABEL     028C 652    .data
outport_img_addr        LABEL     027E 638    .text
outport_init            LABEL     0274 628    .text
OUTPORT_INIT_VAL        ABSOLUTE  0000 0      startup
outport_set_bits        LABEL     0256 598    .text
outport_write           LABEL     0280 640    .text
PEDESTRIAN_BUTTON_MASK  ABSOLUTE  0001 1      startup
PEDESTRIAN_BUTTON_POS   ABSOLUTE  0000 0      startup
PEDESTRIAN_LIGHT_G_MASK ABSOLUTE  0008 8      startup
PEDESTRIAN_LIGHT_R_MASK ABSOLUTE  0004 4      startup
ptc_addr                LABEL     024C 588    .text
PTC_ADDRESS             ABSOLUTE  FF40 65344  startup
ptc_clr_irq             LABEL     0246 582    .text
PTC_CMD_START           ABSOLUTE  0000 0      startup
PTC_CMD_STOP            ABSOLUTE  0001 1      startup
ptc_get_value           LABEL     0240 576    .text
ptc_init                LABEL     021E 542    .text
ptc_start               LABEL     0230 560    .text
ptc_stop                LABEL     0238 568    .text
PTC_TC                  ABSOLUTE  0004 4      startup
PTC_TCR                 ABSOLUTE  0000 0      startup
PTC_TIR                 ABSOLUTE  0006 6      startup
PTC_TMR                 ABSOLUTE  0002 2      startup
STACK_SIZE              ABSOLUTE  0040 64     startup
stack_top               LABEL     02E0 736    .stack
stack_top_addr          LABEL     000E 14     startup
startup_LEDs            LABEL     028D 653    .data
startup_LEDs_addr       LABEL     0042 66     .text
startup_LEDs_Config     LABEL     013C 316    .text
startup_LEDs_Crossing_Cars LABEL     0132 306    .text
startup_LEDs_Pedestrians LABEL     0146 326    .text
state                   LABEL     029E 670    .data
state_addr              LABEL     0040 64     .text
state_addr1             LABEL     00DC 220    .text
state_addr2             LABEL     0118 280    .text
SWI7                    ABSOLUTE  0080 128    startup
sysclk                  LABEL     028A 650    .data
sysclk_addr             LABEL     021C 540    .text
SYSCLK_FREQ             ABSOLUTE  0063 99     startup
sysclk_get_ticks        LABEL     01F6 502    .text
sysclk_init             LABEL     01EA 490    .text
TIME_MASK               ABSOLUTE  00E0 224    startup
TIME_POS                ABSOLUTE  0005 5      startup
timeout                 LABEL     0150 336    .text
TIMEOUT                 ABSOLUTE  0005 5      startup
timeout_l0              LABEL     0164 356    .text
TRAFFIC_LIGHT_G_MASK    ABSOLUTE  0002 2      startup
TRAFFIC_LIGHT_R_MASK    ABSOLUTE  0001 1      startup
turn_cars_off           LABEL     01C6 454    .text
turn_cars_red_on        LABEL     018A 394    .text
turn_cars_yellow_on     LABEL     01DE 478    .text
turn_mode_green_on      LABEL     01AE 430    .text
turn_mode_yellow_on     LABEL     01A2 418    .text
turn_pedestrians_green_on LABEL     01BA 442    .text
turn_pedestrians_off    LABEL     01D2 466    .text
turn_pedestrians_red_on LABEL     0196 406    .text
ZERO                    ABSOLUTE  0000 0      startup

Code listing
   1           	
   2           	; Definicao dos valores dos simbolos utilizados no programa
   3           	;
   4          		.equ	ENABLE_EXTINT, 0x10          ; Mascara para o bit I do registo CPSR
   5           	
   6          		.equ	STACK_SIZE, 64                ; Dimensao do stack - 64 B
   7           	
   8           		; Definicoes do porto de entrada
   9          		.equ	INPORT_ADDRESS, 0xFF80        ; Endereco do porto de entrada
  10           	
  11           		; Definicoes do porto de saida
  12          		.equ	OUTPORT_ADDRESS, 0xFFC0       ; Endereco do porto de saida
  13           	
  14          		.equ	OUTPORT_INIT_VAL, 0           ; Valor inicial do porto de saida
  15           	
  16           		; Definicoes do circuito pTC
  17           	; *** Inicio de troco para completar ***
  18          		.equ	PTC_ADDRESS,  0xFF40          ; Endereco do circuito pTC
  19           	; *** Fim de troco para completar ***
  20           	
  21          		.equ	PTC_TCR, 0                    ; Deslocamento do registo TCR do pTC
  22          		.equ	PTC_TMR, 2                    ; Deslocamento do registo TMR do pTC
  23          		.equ	PTC_TC,  4                    ; Deslocamento do registo TC do pTC
  24          		.equ	PTC_TIR, 6                    ; Deslocamento do registo TIR do pTC
  25           	
  26          		.equ	PTC_CMD_START, 0              ; Comando para iniciar a contagem no pTC
  27          		.equ	PTC_CMD_STOP, 1               ; Comando para parar a contagem no pTC
  28           	
  29          		.equ	SYSCLK_FREQ, 0x63             ; Módulo 99 - Intervalo de contagem do circuito pTC
  30           	                                          ; que suporta a implementação do sysclk
  31           	
  32          		.equ	BLINK_TIME, 5                 ; A cada 0.5 segundos
  33          		.equ	TIMEOUT, 	5
  34          		.equ	ARRAY_MASK, 0x07
  35          		.equ	ARRAY_POS, 0x03
  36          	    .equ    SWI7, 128
  37           	
  38           	
  39           	; Constantes referentes ao porto de entrada e saída
  40          	    .equ    PEDESTRIAN_BUTTON_MASK, 0x01
  41          	    .equ    PEDESTRIAN_BUTTON_POS,  0
  42          	    .equ    CONFIG_MASK,            0x10
  43          	    .equ    CONFIG_POS,             4
  44          	    .equ    TIME_MASK,              0xE0
  45          	    .equ    TIME_POS,               5
  46          	    .equ    TRAFFIC_LIGHT_R_MASK,   0x01
  47          	    .equ    TRAFFIC_LIGHT_G_MASK,   0x02
  48          		.equ	PEDESTRIAN_LIGHT_R_MASK, 0x04
  49          		.equ 	PEDESTRIAN_LIGHT_G_MASK, 0x08
  50          		.equ 	MODE_R_MASK,			 0x10
  51          		.equ 	MODE_G_MASK,			 0x20
  52           	
  53           	
  54           	; Estados da aplicação
  55          	    .equ    CROSSING_CARS_ST,          0
  56          	    .equ    CROSSING_PEDESTRIAN_ST,    2
  57          	    .equ    CONFIG_ST,                 4
  58           	
  59           	; Constantes auxiliares
  60          		.equ 	ZERO,						0
  61          		.equ 	ONE,						1
  62           	
  63           	
  64           	
  65           	; *** Fim de troco para completar ***
  66           	
  67           	; Seccao:    startup
  68           	; Descricao: Guarda o código de arranque do sistema
  69           	;
  70           		.section startup
  71           	
  72 0000 01 58		b		_start
  73 0002 7F 0C		ldr		pc, isr_addr
  74           	_start:
  75 0004 4D 0C		ldr		sp, stack_top_addr
  76 0006 80 B7	    mov 	r0, pc
  77 0008 0E A2	    add 	lr, r0, #4
  78 000A 2F 0C		ldr		pc, main_addr
  79 000C FF 5B	    b   .
  80           	stack_top_addr:
  81 000E E0 02		.word stack_top
  82           	main_addr:
  83 0010 14 00		.word	main
  84           	isr_addr:
  85 0012 FC 01		.word	isr
  86           	
  87           	    .text
  88           	main:
  89 0014 04 24	    push    r4                      ; Estado atual
  90 0016 05 24	    push    r5                      ; Imagem do inport_read
  91 0018 06 24	    push    r6                      ; Referência do clock
  92 001A 07 24		push	r7						; aux
  93 001C 04 60	    mov     r4, #CROSSING_CARS_ST   ; Estado atual = CROSSING_CARS_ST
  94 001E 30 66	    mov     r0, #SYSCLK_FREQ        ; Decidir qual o clock que vamos usar para alterar este valor
  95 0020 E4 5C	    bl      sysclk_init             ; Inicializar o clock
  96 0022 60 B0	    mrs		r0, cpsr
  97 0024 01 61		mov		r1, #ENABLE_EXTINT
  98 0026 80 C8		orr		r0, r0, r1
  99 0028 40 B0		msr		cpsr, r0
 100 002A 13 60		mov 	r3, #ONE
 101           	main_loop:
 102 002C 91 0C		ldr		r1, state_addr						; Carregar endereço da variável state_time
 103 002E 12 60		mov		r2, #ONE							; r2 = 1
 104 0030 12 20		str		r2, [r1]							; Colocar o state a zero inicialmente
 105 0032 0D 5D		bl      inport_read             			; Ler o porto de leitura
 106 0034 05 B0	    mov     r5, R0                  			; r5 = imagem do porto de entrada
 107 0036 CF 87	    add     pc, r4, pc              			; Incrementar o program counter com o valor de acordo o branch a ser efetuado
 108           	main_branch_table:
 109 0038 05 58	    b       case_crossing_cars
 110 003A 1D 58	    b       case_crossing_pedestrians
 111 003C 35 58	    b       case_config
 112 003E 49 58		b		main_end
 113           	state_addr:
 114 0040 9E 02		.word 	state
 115           	startup_LEDs_addr:
 116 0042 8D 02		.word 	startup_LEDs
 117           	
 118           	case_crossing_cars:		;TESTADO E FUNCIONA - Caso timeout a 1 e a 0 
 119 0044 76 5C		bl		startup_LEDs_Crossing_Cars
 120           	case_crossing_cars_begin:
 121 0046 80 B2		mov		r0, r5
 122 0048 94 5C		bl 		get_config							; De acordo a imagem do porto de entrada vê a config
 123 004A 01 60		mov 	r1, #ZERO							; r1 = 0
 124 004C 80 B8		cmp 	r0, r1								; r0 - r1
 125 004E 0F 44		bzc		case_crossing_cars_l0				; se r0 != r1 -> vai para estado config, caso contrário vai continuar testando o button
 126 0050 80 B2		mov		r0, r5
 127 0052 89 5C		bl 		get_pedestrian_button
 128 0054 62 5C		bl		detect_rising_edge					; de acordo com o valor now ele verifica se houve uma transição ascedente retornando true
 129 0056 11 60		mov		r1, #ONE
 130 0058 10 B8		cmp		r1, r0								; r1(1) - r0 (1 ou 0)
 131 005A 0B 40		bzs 	case_crossing_cars_l1				;se houve raising_edge ele passa para o estado seguinte (r0 -> true == ONE) muda de estado
 132 005C 00 B3		mov		r0, r6								; r0 = referência do tempo
 133 005E 51 60		mov 	r1, #BLINK_TIME						; r1 = #BLINK_TIME
 134 0060 77 5C		bl 		timeout								; testar timeout_blink
 135 0062 12 60		mov 	r2, #ONE
 136 0064 00 B9		cmp 	r0, r2								; timeout(1) - 1 = 0 logo entra no if
 137 0066 EF 47		bzc		case_crossing_cars_begin					; flag z a zero salta, caso contrário continua
 138 0068 3B 5C		bl 		evaluate_state_cars					; avalia o state do tempo baseado no timeout
 139 006A 01 60		mov		r1, #ZERO
 140 006C EC 5B		b 		case_crossing_cars_begin					; continua neste caso até que config a '0' e button a '1' ou config a '1'
 141           	case_crossing_cars_l0:
 142 006E 44 60		mov		r4, #CONFIG_ST
 143 0070 DD 5B		b		main_loop
 144           	case_crossing_cars_l1:
 145 0072 24 60		mov 	r4, #CROSSING_PEDESTRIAN_ST
 146 0074 DB 5B		b		main_loop
 147           	case_crossing_pedestrians:
 148 0076 67 5C		bl		startup_LEDs_Pedestrians
 149           	case_crossing_pedestrians_begin:
 150 0078 80 B2		mov 	r0, r5
 151 007A 7B 5C		bl 		get_config
 152 007C 11 60		mov 	r1, #ONE							; r1 = 1
 153 007E 80 B8		cmp 	r0, r1								; r0 - r1, se for 0 significa que r0 = r1 = 1 
 154 0080 0F 40		bzs		case_crossing_pedestrians_l0		; se for false testa times
 155 0082 80 B2		mov		r0, r5
 156 0084 81 B3		mov		r1, r7	
 157 0086 00 B3		mov		r0, r6								; timeref
 158 0088 63 5C		bl		timeout								; verifica timeout da luz dos peões
 159 008A 11 60		mov		r1, #ONE							; r1 = 1
 160 008C 80 B8		cmp 	r0, r1								; timeout - 1
 161 008E 0A 40		bzs		case_crossing_pedestrians_l1		; if timeout - 1 for false testa button
 162 0090 80 B2		mov 	r0, r5
 163 0092 69 5C		bl 		get_pedestrian_button
 164 0094 01 60		mov		r1, #ZERO							; r1 = #ZERO 
 165 0096 80 B8		cmp 	r0, r1								; r0 - r1 
 166 0098 EF 47		bzc		case_crossing_pedestrians_begin			; if button - 0 for false tirar ref do tempo e saltar para o estado case_crossing_pedestrians
 167 009A AD 5C		bl		sysclk_get_ticks
 168 009C 06 B0		mov		r6, r0	
 169 009E EC 5B		b		case_crossing_pedestrians_begin
 170           	
 171           	case_crossing_pedestrians_l0:
 172 00A0 44 60		mov		r4, #CONFIG_ST
 173 00A2 C4 5B		b		main_loop
 174           	case_crossing_pedestrians_l1:
 175 00A4 04 60		mov 	r4, #CROSSING_CARS_ST
 176 00A6 C2 5B		b		main_loop
 177           	case_config:
 178 00A8 49 5C		bl		startup_LEDs_Config
 179           	case_config_begin:
 180 00AA 63 5C		bl 		get_config
 181 00AC 01 60		mov 	r1, #ZERO							; r1 = 0
 182 00AE 80 B8		cmp 	r0, r1								; r0 - r1, se for 1 significa que r0 = r1 = 1 
 183 00B0 0E 40		bzs		case_config_l0						; se for false, testa timeout
 184           		
 185 00B2 65 5C		bl 		get_time
 186 00B4 80 E0		lsl		r0, r0, #1
 187 00B6 31 0D		ldr		r1, crossing_times_addr				; Carrega o endereço de crossing_times disponíveis para o led dos peões
 188 00B8 11 10		ldr 	r1, [r1, r0]						; Indexa o array de crossing times de acordo o valor presente dos 3 bits de maior peso do porto de entrada
 189 00BA 87 B0		mov		r7, r1
 190           	
 191 00BC 00 B3		mov		r0, r6								; Colocar a referência do tempo em r0
 192 00BE 51 60		mov		r1, #BLINK_TIME						; Colocar em r1 o valor que quero passar ao timeout
 193 00C0 47 5C		bl 		timeout								; Avalia se houve timeout
 194 00C2 12 60		mov 	r2, #ONE							; r1 = 0
 195 00C4 00 B9		cmp 	r0, r2								; r0 - r1
 196 00C6 F1 47		bzc		case_config_begin							; se for false, testa state								; variável state referente ao tempo
 197 00C8 18 5C		bl 		evaluate_state_config				; avalia o state do tempo baseado no timeout
 198 00CA 01 60		mov 	r1, #ZERO
 199 00CC EE 5B		b 		case_config_begin
 200           	case_config_l0:
 201 00CE 04 60		mov 	r4, #CROSSING_CARS_ST
 202 00D0 AD 5B		b 		main_loop
 203           	main_end:
 204 00D2 07 04		pop		r7
 205 00D4 06 04		pop 	r6
 206 00D6 05 04		pop		r5
 207 00D8 04 04		pop		r4
 208 00DA 0F 04		pop		pc
 209           	
 210           	state_addr1:
 211 00DC 9E 02		.word 	state
 212           	
 213           	crossing_times_addr:
 214 00DE 8E 02	    .word   crossing_times
 215           	
 216           	
 217           	/*
 218           	fun evaluateStateTime(timeout: Boolean).{
 219           		if(timout == true(1)){
 220           			if(stateActual == true){
 221           				outportSetBits (of L1 to green and L2 to red)
 222           			}
 223           			else outportClrBits (of L1 to nothing and L2 to nothing)
 224           		}
 225           	
 226           	}
 227           	*/
 228           	
 229           	; Testada - Funciona tanto para Timeout = 0 e Timeout = 1
 230           	; r0 = timeout
 231           	evaluate_state_cars:
 232 00E0 0E 24		push 	lr
 233 00E2 A1 0D		ldr		r1, state_addr2
 234 00E4 11 00		ldr		r1, [r1]
 235 00E6 10 B9		cmp 	r1, r2							; state_time - 1
 236 00E8 03 40		bzs		evaluate_state_cars_l1				; flag z a zero salta, caso contrário continua
 237 00EA 79 5C		bl		turn_cars_yellow_on				; L1 a verde
 238 00EC 12 60		mov 	r2, #ONE
 239 00EE 02 58		b		evaluate_state_cars_l2
 240           	evaluate_state_cars_l1:
 241 00F0 6A 5C		bl		turn_cars_off
 242 00F2 02 60		mov 	r2, #ZERO
 243           	evaluate_state_cars_l2:
 244 00F4 11 0D		ldr		r1, state_addr2
 245 00F6 12 20		str		r2, [r1]
 246           	evaluate_state_cars_l0:	
 247 00F8 0F 04		pop 	pc
 248           	
 249           	
 250           	; r0 = timeout, r1 = stateAtual
 251           	evaluate_state_config:
 252 00FA 0E 24		push 	lr
 253 00FC D1 0C		ldr		r1, state_addr2
 254 00FE 11 00		ldr		r1, [r1]
 255 0100 10 B9		cmp 	r1, r2	
 256 0102 04 40		bzs		evaluate_state_config_l1		; flag z a zero salta, caso contrário continua
 257 0104 6C 5C		bl		turn_cars_yellow_on
 258 0106 59 5C		bl		turn_pedestrians_green_on
 259 0108 12 60		mov 	r2, #ONE
 260 010A 03 58		b		evaluate_state_config_l2
 261           	evaluate_state_config_l1:
 262 010C 5C 5C		bl		turn_cars_off
 263 010E 61 5C		bl		turn_pedestrians_off
 264 0110 02 60		mov 	r2, #ZERO
 265           	evaluate_state_config_l2:
 266 0112 21 0C		ldr		r1, state_addr2
 267 0114 12 20		str		r2, [r1]
 268           	evaluate_state_config_l0:
 269 0116 0F 04		pop 	pc
 270           	
 271           	state_addr2:
 272 0118 9E 02		.word 	state
 273           	
 274           	/*
 275           	uint8_t b_last;
 276           	uint8_t detect_raising_edge(uint8_t b_now) : boolean {
 277           		uint8_t raising_edge = b_last == 0 && b_now == 1;
 278           		if(raising_edge == true){
 279           			b_last = b_now;
 280           		return raising_edge;
 281           		}
 282           		else {
 283           			b_last = b_now;
 284           		return raising_edge;
 285           		}
 286           		
 287           	}
 288           	*/
 289           	
 290           	
 291           	detect_rising_edge:
 292 011A 11 60		mov			r1, #PEDESTRIAN_BUTTON_MASK
 293 011C 81 C0		and			r1, r0, r1				; R1 = blink_ena_now
 294 011E 00 60		mov			r0, #0					; rising_edge = FALSE
 295 0120 72 0C		ldr			r2, button_state_addr ; alterar «nome
 296 0122 04 40		bzs			detect_rising_edge_l0 ; blink_ena_now == 1
 297 0124 23 08		ldrb		r3, [r2]				; R3 = blink_ena_last
 298 0126 B3 C1		and			r3, r3, r3
 299 0128 01 44		bzc			detect_rising_edge_l0 ; blink_ena_last == 0
 300 012A 10 60		mov			r0, #1					; rising_edge = TRUE
 301           	detect_rising_edge_l0:
 302 012C 21 28		strb		r1, [r2]
 303 012E 0F B7		mov			pc, lr					; return rising_edge
 304           	
 305           	button_state_addr:
 306 0130 88 02	    .word   button_state
 307           	
 308           		
 309           	startup_LEDs_Crossing_Cars:
 310 0132 0E 24		push 	lr
 311 0134 54 5C		bl 		turn_cars_yellow_on					; L1 a verde
 312 0136 2F 5C		bl		turn_pedestrians_red_on				; L2 a vermelho
 313 0138 3A 5C		bl 		turn_mode_green_on					; L3 a verde
 314 013A 0F 04		pop 	pc
 315           	
 316           	startup_LEDs_Config:
 317 013C 0E 24		push 	lr
 318 013E 4F 5C		bl 		turn_cars_yellow_on					; L1 a amarelo
 319 0140 3C 5C		bl 		turn_pedestrians_green_on			; L2 a verde
 320 0142 2F 5C		bl		turn_mode_yellow_on					; L3 a amarelo
 321 0144 0F 04		pop 	pc
 322           	
 323           	
 324           	startup_LEDs_Pedestrians:
 325 0146 0E 24		push 	lr
 326 0148 20 5C		bl 		turn_cars_red_on					; L1 a verde
 327 014A 37 5C		bl		turn_pedestrians_green_on			; L2 a vermelho
 328 014C 30 5C		bl 		turn_mode_green_on					; L3 a verde
 329 014E 0F 04		pop 	pc
 330           	
 331           	
 332           	/* fun timeout(timeRef, timeToCompare):{
 333           		val presentTime = sysclk_get_ticks()
 334           		val sub = presentTime - timeRef
 335           		var timeout = false
 336           	
 337           		if(sub >= timeToCompare) timeout = true
 338           		else timeout = false
 339           	
 340           		return timeout
 341           	}*/
 342           	; r0= timeRef, r1= timeToCompare
 343           	; TESTADO E ESTÁ A FUNCIONAR
 344           	timeout:
 345 0150 0E 24		push 	lr
 346 0152 02 B0		mov		r2, r0					; timeref
 347 0154 50 5C		bl 		sysclk_get_ticks		; Tempo atual em ticks
 348 0156 02 89		sub 	r2, r0, r2				; sub
 349 0158 00 60		mov		r0, #0					; timeout = false
 350 015A A0 B8		cmp 	r2, r1					; timeToCompare - sub
 351 015C 03 4C		blo		timeout_l0				; caso seja menor salta
 352 015E 4B 5C		bl 		sysclk_get_ticks					; Tirar nova referência de tempo
 353 0160 06 B0		mov 	r6, r0	
 354 0162 10 60		mov		r0, #1					; timeout = true
 355           	timeout_l0:
 356 0164 0F 04		pop		pc
 357           	
 358           	
 359           	;-----------------------------------------------------
 360           	
 361           	; Camada aplicacional
 362           	
 363           	;-----------------------------------------------------
 364           	
 365           	; uint8_t get_pedestrian_button(uint8_t inport_val)
 366           	get_pedestrian_button:
 367 0166 0E 24		push	lr
 368 0168 72 5C		bl      inport_read             			; Ler o porto de leitura
 369 016A 11 60	    mov     r1, #PEDESTRIAN_BUTTON_MASK
 370 016C 80 C0	    and     r0, r0, r1
 371 016E 00 E8	    lsr     r0, r0, #PEDESTRIAN_BUTTON_POS
 372 0170 0F 04		pop		pc
 373           	; uint8_t get_config(uint8_t inport_val)
 374           	get_config:
 375 0172 0E 24		push	lr
 376 0174 6C 5C		bl      inport_read             			; Ler o porto de leitura
 377 0176 01 61	    mov     r1, #CONFIG_MASK
 378 0178 80 C0	    and     r0, r0, r1
 379 017A 00 EA	    lsr     r0, r0, #CONFIG_POS
 380 017C 0F 04	    pop		pc
 381           	
 382           	; uint8_t get_time(uint8_t inport_val)
 383           	get_time:
 384 017E 0E 24		push	lr
 385 0180 66 5C		bl      inport_read             			; Ler o porto de leitura
 386 0182 01 6E	    mov     r1, #TIME_MASK
 387 0184 80 C0	    and     r0, r0, r1
 388 0186 80 EA	    lsr     r0, r0, #TIME_POS
 389 0188 0F 04	    pop		pc
 390           	
 391           	turn_cars_red_on:
 392 018A 0E 24		push 	lr
 393 018C 20 60		mov 	r0, #TRAFFIC_LIGHT_G_MASK
 394 018E 6A 5C		bl		outport_clear_bits
 395 0190 10 60		mov		r0, #TRAFFIC_LIGHT_R_MASK
 396 0192 61 5C		bl		outport_set_bits
 397 0194 0F 04		pop 	pc
 398           	
 399           	turn_pedestrians_red_on:
 400 0196 0E 24		push	lr
 401 0198 80 60		mov 	r0, #PEDESTRIAN_LIGHT_G_MASK
 402 019A 64 5C		bl		outport_clear_bits
 403 019C 40 60		mov		r0, #PEDESTRIAN_LIGHT_R_MASK
 404 019E 5B 5C		bl		outport_set_bits
 405 01A0 0F 04		pop		pc
 406           	
 407           	turn_mode_yellow_on:
 408 01A2 0E 24		push 	lr
 409 01A4 00 62		mov 	r0, #MODE_G_MASK
 410 01A6 57 5C		bl		outport_set_bits
 411 01A8 00 61		mov		r0, #MODE_R_MASK
 412 01AA 55 5C		bl		outport_set_bits
 413 01AC 0F 04		pop 	pc
 414           	
 415           	turn_mode_green_on:
 416 01AE 0E 24		push 	lr
 417 01B0 00 62		mov 	r0, #MODE_G_MASK
 418 01B2 51 5C		bl		outport_set_bits
 419 01B4 00 61		mov		r0, #MODE_R_MASK
 420 01B6 56 5C		bl		outport_clear_bits
 421 01B8 0F 04		pop 	pc
 422           	
 423           	turn_pedestrians_green_on:
 424 01BA 0E 24		push	lr
 425 01BC 80 60		mov 	r0, #PEDESTRIAN_LIGHT_G_MASK
 426 01BE 4B 5C		bl		outport_set_bits
 427 01C0 40 60		mov		r0, #PEDESTRIAN_LIGHT_R_MASK
 428 01C2 50 5C		bl		outport_clear_bits
 429 01C4 0F 04		pop		pc
 430           	
 431           	turn_cars_off:
 432 01C6 0E 24		push	lr
 433 01C8 20 60		mov 	r0, #TRAFFIC_LIGHT_G_MASK
 434 01CA 4C 5C		bl 		outport_clear_bits
 435 01CC 10 60		mov 	r0, #TRAFFIC_LIGHT_R_MASK
 436 01CE 4A 5C		bl 		outport_clear_bits
 437 01D0 0F 04		pop 	pc
 438           	
 439           	turn_pedestrians_off:
 440 01D2 0E 24		push 	lr
 441 01D4 80 60		mov		r0, #PEDESTRIAN_LIGHT_G_MASK
 442 01D6 46 5C		bl 		outport_clear_bits
 443 01D8 40 60		mov		r0, #PEDESTRIAN_LIGHT_R_MASK
 444 01DA 44 5C		bl 		outport_clear_bits
 445 01DC 0F 04		pop		pc
 446           	
 447           	turn_cars_yellow_on:
 448 01DE 0E 24		push 	lr
 449 01E0 20 60		mov		r0, #TRAFFIC_LIGHT_G_MASK
 450 01E2 39 5C		bl 		outport_set_bits
 451 01E4 10 60		mov		r0, #TRAFFIC_LIGHT_R_MASK
 452 01E6 37 5C		bl 		outport_set_bits
 453 01E8 0F 04		pop		pc
 454           	
 455           	;--------------------------------------------------------------------
 456           	
 457           	; Rotinas referentes ao Pico-Timer
 458           	
 459           	sysclk_init:
 460 01EA 0E 24		push 	lr
 461 01EC 18 5C		bl		ptc_init			; Recebe em r0 o valor do intervalo (do módulo para o TMR) e inicia o pTC
 462 01EE 00 60		mov		r0, #0
 463 01F0 51 0D		ldr		r1, sysclk_addr		; Inicializa a variável em memória sysclk a zero
 464 01F2 10 20		str		r0, [r1, #0]
 465 01F4 0F 04		pop		pc
 466           	
 467           	sysclk_get_ticks:
 468 01F6 20 0D		ldr		r0, sysclk_addr
 469 01F8 00 00		ldr		r0, [r0]
 470 01FA 0F B7		mov		pc, lr
 471           	
 472           	isr:
 473 01FC 0E 24		push	lr
 474 01FE 00 24		push 	r0
 475 0200 01 24		push 	r1
 476 0202 02 24		push	r2
 477 0204 03 24		push	r3
 478 0206 A1 0C		ldr		r1, sysclk_addr
 479 0208 10 00		ldr		r0, [r1]
 480 020A 80 A0		add		r0, r0, #1
 481 020C 10 20		str		r0, [r1]			; Incrementa o valor da variável global sysclk
 482 020E 1B 5C		bl		ptc_clr_irq
 483 0210 03 04		pop		r3
 484 0212 02 04		pop		r2
 485 0214 01 04		pop		r1
 486 0216 00 04		pop		r0
 487 0218 0E 04		pop		lr
 488 021A 20 B0		movs 	pc, lr	
 489           	
 490           	sysclk_addr:
 491 021C 8A 02		.word	sysclk
 492           	
 493           	ptc_init:
 494 021E 0E 24	    push    lr
 495 0220 51 0D		ldr		r1, ptc_addr
 496 0222 12 60		mov		r2, #PTC_CMD_STOP
 497 0224 12 28		strb	r2, [r1, #PTC_TCR]
 498 0226 10 29		strb	r0, [r1, #PTC_TMR]
 499 0228 0E 5C	    bl  	ptc_clr_irq
 500 022A 02 60		mov		r2, #PTC_CMD_START
 501 022C 12 28		strb	r2, [r1, #PTC_TCR]
 502 022E 0F 04		pop 	pc
 503           	
 504           	ptc_start:
 505 0230 D0 0C		ldr		r0, ptc_addr
 506 0232 01 60		mov		r1, #PTC_CMD_START
 507 0234 01 28		strb	r1, [r0, #PTC_TCR]
 508 0236 0F B7		mov		pc, lr
 509           	
 510           	ptc_stop:
 511 0238 90 0C		ldr		r0, ptc_addr
 512 023A 11 60		mov		r1, #PTC_CMD_STOP
 513 023C 01 28		strb	r1, [r0, #PTC_TCR]
 514 023E 0F B7		mov		pc, lr
 515           	
 516           	ptc_get_value:
 517 0240 51 0C		ldr		r1, ptc_addr
 518 0242 10 0A		ldrb	r0, [r1, #PTC_TC]
 519 0244 0F B7		mov		pc, lr
 520           	
 521           	ptc_clr_irq:
 522 0246 20 0C		ldr		r0, ptc_addr
 523 0248 01 2B		strb	r1, [r0, #PTC_TIR]
 524 024A 0F B7		mov		pc, lr
 525           	
 526           	ptc_addr:
 527 024C 40 FF		.word	PTC_ADDRESS
 528           	
 529           	
 530           	inport_read:
 531 024E 21 0C		ldr		r1, inport_addr
 532 0250 10 08		ldrb	r0, [r1, #0]
 533 0252 0F B7		mov		pc, lr
 534           	
 535           	inport_addr:
 536 0254 80 FF		.word	INPORT_ADDRESS
 537           	
 538           	outport_set_bits:
 539 0256 0E 24		push	lr
 540 0258 21 0D		ldr		r1, outport_img_addr
 541 025A 12 08		ldrb	r2, [r1, #0]
 542 025C 20 C8		orr		r0, r2, r0
 543 025E 10 28		strb	r0, [r1, #0]
 544 0260 0F 5C		bl		outport_write
 545 0262 0F 04		pop		pc
 546           	
 547           	outport_clear_bits:
 548 0264 0E 24		push	lr
 549 0266 B1 0C		ldr		r1, outport_img_addr
 550 0268 12 08		ldrb	r2, [r1, #0]
 551 026A 10 B0		mvn		r0, r0
 552 026C 20 C0		and		r0, r2, r0
 553 026E 10 28		strb	r0, [r1]
 554 0270 07 5C		bl		outport_write
 555 0272 0F 04		pop		pc
 556           	
 557           	outport_init:
 558 0274 0E 24		push	lr
 559 0276 31 0C		ldr		r1, outport_img_addr
 560 0278 10 28		strb	r0, [r1]
 561 027A 02 5C		bl		outport_write
 562 027C 0F 04		pop		pc
 563           	
 564           	outport_img_addr:
 565 027E 8C 02		.word	outport_img
 566           	
 567           	outport_write:
 568 0280 21 0C		ldr		r1, outport_addr
 569 0282 10 28		strb	r0, [r1, #0]
 570 0284 0F B7		mov		pc, lr
 571           	
 572           	
 573           	outport_addr:
 574 0286 C0 FF		.word	OUTPORT_ADDRESS
 575           	
 576           		.data
 577           	
 578           	button_state:
 579 0288 00   	    .space 1
 580           	
 581           	led_state:
 582 0289 00   	    .space 1
 583           	
 584           	sysclk:
 585 028A 00   		.space	2
 585 028B 00
 586           	
 587           	outport_img:
 588 028C 00   		.space	1
 589           	
 590           	startup_LEDs:
 591 028D 00   		.space	1
 592           	
 593           	crossing_times:
 594          	    .word       100, 150, 200, 250, 300, 300, 300, 300
 594 028E 64 00 96 00 C8 00 FA 00 2C 01 2C 01 2C 01 2C 01
 595           	
 596           	state:
 597 029E 00   		.space 1
 598           	
 599           		.section .stack
 600 02A0 00   		.space	STACK_SIZE
 600 .... ..
 600 02DF 00
 601           	stack_top:
 601           	
